name: repo2docker-dockerhub
on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-and-push:
    if: ${{ github.actor != 'github-actions[bot]' }}
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        submodules: recursive

    - name: Update submodules to latest remote main
      run: |
        set -euo pipefail
        echo "Synchronizing submodule config (branch=main)";
        git submodule sync --recursive
        echo "Fetching & updating submodules to their configured branches";
        # This respects branch= entries in .gitmodules (now set to main)
        git submodule update --init --remote --recursive
        # Force each submodule to the exact origin/main (avoids stale local main)
        git submodule foreach --recursive 'branch=$(git config -f $toplevel/.gitmodules submodule.$name.branch || echo main); git fetch origin $branch; git checkout $branch || git checkout -b $branch; git reset --hard origin/$branch; echo "$name -> $(git rev-parse --short HEAD)"'
        echo "Final submodule status:"; git submodule status --recursive

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Back up and remove binder/Dockerfile for CI build
      run: |
        if [ -f binder/Dockerfile ]; then
          echo "Backing up binder/Dockerfile then removing for CI build so repo2docker copies repo contents"
          cp binder/Dockerfile binder/Dockerfile.ci.bak
          rm -f binder/Dockerfile
        fi

    - name: Derive lowercase image name (Quay.io)
      run: |
        REPO_NAME="${GITHUB_REPOSITORY#*/}"
        REPO_NAME_LC="$(echo "$REPO_NAME" | tr '[:upper:]' '[:lower:]')"
        echo "REPO_NAME_LC=$REPO_NAME_LC" >> $GITHUB_ENV
        echo "IMAGE_NAME=${{ secrets.QUAYIO_USERNAME }}/$REPO_NAME_LC" >> $GITHUB_ENV

  # - name: Build and push with repo2docker (Docker Hub)  # Disabled for Quay-only test
  #   id: r2d
  #   uses: jupyterhub/repo2docker-action@master
  #   with:
  #     DOCKER_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  #     DOCKER_PASSWORD: ${{ secrets.DOCKERHUB_TOKEN }}
  #     DOCKER_REGISTRY: docker.io
  #     IMAGE_NAME: ${{ env.IMAGE_NAME }}
  #     # Do not set BINDER_CACHE (Quay-specific)

    - name: Build and push with repo2docker (Quay.io with Binder cache)
      id: r2d-quay
      uses: jupyterhub/repo2docker-action@master
      with:
        DOCKER_USERNAME: ${{ secrets.QUAYIO_USERNAME }}
        DOCKER_PASSWORD: ${{ secrets.QUAYIO_PASSWORD }}
        DOCKER_REGISTRY: quay.io
        IMAGE_NAME: ${{ env.IMAGE_NAME }}
        BINDER_CACHE: true

    - name: Compute short SHA and image ref
      run: |
        SHORT_SHA="${GITHUB_SHA::12}"
        echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
        # Use Quay image name for FROM reference
        echo "IMAGE_REF=${{ env.IMAGE_NAME }}:$SHORT_SHA" >> $GITHUB_ENV

    - name: Restore binder/Dockerfile and update FROM tag (preserve COPY lines)
      run: |
        if [ -f binder/Dockerfile.ci.bak ]; then
          mv -f binder/Dockerfile.ci.bak binder/Dockerfile
        else
          echo "# Github Action Built Image" > binder/Dockerfile
          echo "FROM $IMAGE_REF" >> binder/Dockerfile
        fi
        sed -E -i '1,/^FROM / s|^FROM .*$|FROM '"$IMAGE_REF"'|' binder/Dockerfile
        echo "Updated FROM in binder/Dockerfile to $IMAGE_REF"
    - name: Append submodule hashes and commit URLs to Dockerfile
      run: |
        # Truncate Dockerfile to only keep header and FROM line
        if grep -q '^FROM ' binder/Dockerfile; then
          sed -n '1,/^FROM /p' binder/Dockerfile > binder/Dockerfile.__trim && mv binder/Dockerfile.__trim binder/Dockerfile
        fi
        ts=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
        echo "# Submodule hashes and commit URLs for this build (generated at $ts UTC, parent repo $GITHUB_SHA)" >> binder/Dockerfile
        if [ -f .gitmodules ]; then
          echo "# (Debug) Listing submodule pointers from git ls-tree:" >> binder/Dockerfile
          git ls-tree HEAD | grep commit || true >> binder/Dockerfile
          for submodule in $(git config --file .gitmodules --get-regexp path | awk '{print $2}'); do
            url=$(git config -f .gitmodules submodule.$submodule.url || echo "UNKNOWN_URL")
            # Get recorded pointer SHA from index/tree (works even if submodule not initialized)
            pointer=$(git ls-tree HEAD "$submodule" 2>/dev/null | awk '{print $3}')
            if [ -z "$pointer" ]; then
              # Fallback: try looking at working tree if initialized
              pointer=$(git -C "$submodule" rev-parse HEAD 2>/dev/null || echo "UNKNOWN_HASH")
            fi
            if [ "$pointer" != "UNKNOWN_HASH" ] && [ -n "$pointer" ]; then
              pointer_short=${pointer:0:12}
            else
              pointer_short=$pointer
            fi
            norm_url=$url
            case "$norm_url" in
              git@github.com:*) norm_url=https://github.com/$(echo "$norm_url" | sed 's#git@github.com:##; s#\.git$##');;
              *.git) norm_url=$(echo "$norm_url" | sed 's#\.git$##');;
            esac
            if echo "$norm_url" | grep -q '^https://github.com/'; then
              if [ "$pointer" = "UNKNOWN_HASH" ] || [ -z "$pointer" ]; then
                echo "# $submodule: (could not determine commit) $norm_url" >> binder/Dockerfile
              else
                echo "# $submodule: $pointer_short $norm_url/tree/$pointer_short" >> binder/Dockerfile
              fi
            else
              echo "# $submodule: $pointer_short $url/tree/$pointer_short" >> binder/Dockerfile
            fi
          done
        else
          echo "# (No submodules)" >> binder/Dockerfile
        fi

    - name: Commit and push binder/Dockerfile (with submodule pointers) and retry on race
      env:
        GIT_AUTHOR_NAME: github-actions
        GIT_AUTHOR_EMAIL: 41898282+github-actions[bot]@users.noreply.github.com
        GIT_COMMITTER_NAME: github-actions
        GIT_COMMITTER_EMAIL: 41898282+github-actions[bot]@users.noreply.github.com
      run: |
        set -euo pipefail
        # Collect submodule paths (if any) to stage pointer updates
        SUBMODULE_PATHS=""
        if [ -f .gitmodules ]; then
          SUBMODULE_PATHS=$(git config --file .gitmodules --get-regexp path | awk '{print $2}' | tr '\n' ' ' || true)
        fi
        echo "Submodule paths: $SUBMODULE_PATHS"
        git add binder/Dockerfile $SUBMODULE_PATHS || true
        if git diff --cached --quiet; then
          echo "No changes (binder or submodule pointers) to commit"; exit 0; fi
        COMMIT_MSG="chore: update Binder base image tag"
        if [ -n "$SUBMODULE_PATHS" ]; then
          COMMIT_MSG="$COMMIT_MSG and submodule pointers"
        fi
        git commit -m "$COMMIT_MSG"
        attempts=5
        for i in $(seq 1 $attempts); do
          echo "Attempt $i push..."
          if git push origin HEAD:main; then
            echo "Push succeeded"; exit 0; fi
          echo "Initial/previous push failed, attempting to rebase onto origin/main and retry (attempt $i).";
          git fetch origin
          git rebase origin/main || { echo "Rebase failed; aborting."; git rebase --abort || true; exit 1; }
          sleep $((3 * i))
        done
        echo "Failed to push after $attempts attempts"; exit 1